
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Sun Aug 12 18:57:48 CEST 2018
//----------------------------------------------------

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import java.util.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.MJParser.ScopeEnum;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.mj.runtime.Code;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Sun Aug 12 18:57:48 CEST 2018
  */
public class MJParser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public MJParser() {super();}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\146\000\002\002\010\000\002\002\004\000\002\040" +
    "\003\000\002\003\004\000\002\003\002\000\002\004\003" +
    "\000\002\004\003\000\002\004\003\000\002\050\002\000" +
    "\002\051\002\000\002\052\002\000\002\016\014\000\002" +
    "\042\003\000\002\042\003\000\002\042\003\000\002\053" +
    "\002\000\002\017\010\000\002\017\002\000\002\005\004" +
    "\000\002\005\002\000\002\054\002\000\002\006\010\000" +
    "\002\007\006\000\002\007\002\000\002\013\004\000\002" +
    "\013\002\000\002\055\002\000\002\010\012\000\002\012" +
    "\005\000\002\012\002\000\002\011\004\000\002\011\002" +
    "\000\002\043\003\000\002\014\004\000\002\014\002\000" +
    "\002\056\002\000\002\057\002\000\002\060\002\000\002" +
    "\015\016\000\002\044\003\000\002\044\003\000\002\022" +
    "\003\000\002\022\002\000\002\020\005\000\002\020\003" +
    "\000\002\021\005\000\002\025\004\000\002\025\002\000" +
    "\002\026\003\000\002\026\003\000\002\032\007\000\002" +
    "\032\011\000\002\033\004\000\002\033\011\000\002\033" +
    "\011\000\002\033\004\000\002\033\004\000\002\033\004" +
    "\000\002\033\005\000\002\033\007\000\002\033\007\000" +
    "\002\033\005\000\002\034\005\000\002\034\006\000\002" +
    "\034\004\000\002\034\004\000\002\046\005\000\002\046" +
    "\003\000\002\045\005\000\002\045\003\000\002\047\003" +
    "\000\002\047\006\000\002\047\003\000\002\047\003\000" +
    "\002\047\003\000\002\047\007\000\002\047\004\000\002" +
    "\047\005\000\002\023\003\000\002\023\002\000\002\024" +
    "\005\000\002\024\003\000\002\035\005\000\002\035\003" +
    "\000\002\036\005\000\002\036\003\000\002\037\005\000" +
    "\002\037\003\000\002\041\003\000\002\041\005\000\002" +
    "\041\006\000\002\031\003\000\002\031\003\000\002\031" +
    "\003\000\002\031\003\000\002\031\003\000\002\031\003" +
    "\000\002\027\003\000\002\027\003\000\002\030\003\000" +
    "\002\030\003\000\002\030\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\265\000\004\004\005\001\002\000\004\002\267\001" +
    "\002\000\004\054\006\001\002\000\012\006\uffff\022\uffff" +
    "\027\uffff\054\uffff\001\002\000\012\006\ufffd\022\ufffd\027" +
    "\ufffd\054\ufffd\001\002\000\012\006\020\022\021\027\012" +
    "\054\013\001\002\000\004\054\257\001\002\000\010\015" +
    "\uffdf\030\uffdf\054\uffdf\001\002\000\052\024\uffe1\025\uffe1" +
    "\026\uffe1\027\uffe1\031\uffe1\032\uffe1\035\uffe1\036\uffe1\037" +
    "\uffe1\040\uffe1\041\uffe1\042\uffe1\043\uffe1\046\uffe1\047\uffe1" +
    "\050\uffe1\051\uffe1\052\uffe1\053\uffe1\054\uffe1\001\002\000" +
    "\012\006\ufffb\022\ufffb\027\ufffb\054\ufffb\001\002\000\012" +
    "\006\ufffa\022\ufffa\027\ufffa\054\ufffa\001\002\000\012\006" +
    "\ufffe\022\ufffe\027\ufffe\054\ufffe\001\002\000\012\006\ufffc" +
    "\022\ufffc\027\ufffc\054\ufffc\001\002\000\004\054\043\001" +
    "\002\000\004\054\013\001\002\000\004\054\023\001\002" +
    "\000\004\034\ufff9\001\002\000\004\034\025\001\002\000" +
    "\010\055\027\056\031\057\026\001\002\000\006\031\ufff3" +
    "\032\ufff3\001\002\000\006\031\ufff5\032\ufff5\001\002\000" +
    "\006\031\ufff8\032\ufff8\001\002\000\006\031\ufff4\032\ufff4" +
    "\001\002\000\006\031\ufff0\032\ufff0\001\002\000\006\031" +
    "\ufff7\032\034\001\002\000\004\054\037\001\002\000\004" +
    "\031\036\001\002\000\012\006\ufff6\022\ufff6\027\ufff6\054" +
    "\ufff6\001\002\000\004\034\ufff2\001\002\000\004\034\041" +
    "\001\002\000\010\055\027\056\031\057\026\001\002\000" +
    "\006\031\ufff1\032\ufff1\001\002\000\006\020\045\027\uffe2" +
    "\001\002\000\004\027\047\001\002\000\004\054\013\001" +
    "\002\000\004\027\uffe3\001\002\000\010\027\uffe7\030\uffe7" +
    "\054\uffe7\001\002\000\010\027\uffee\030\uffee\054\uffee\001" +
    "\002\000\010\027\053\030\uffe4\054\013\001\002\000\004" +
    "\030\254\001\002\000\010\015\uffdf\030\uffdf\054\uffdf\001" +
    "\002\000\010\027\uffef\030\uffef\054\uffef\001\002\000\010" +
    "\015\061\030\057\054\013\001\002\000\004\054\uffda\001" +
    "\002\000\004\030\uffe5\001\002\000\010\015\uffe0\030\uffe0" +
    "\054\uffe0\001\002\000\004\054\uffd9\001\002\000\004\054" +
    "\063\001\002\000\004\023\uffde\001\002\000\004\023\065" +
    "\001\002\000\006\024\uffd7\054\013\001\002\000\004\054" +
    "\250\001\002\000\006\024\uffd8\032\246\001\002\000\004" +
    "\024\072\001\002\000\006\024\uffd5\032\uffd5\001\002\000" +
    "\006\027\uffdd\054\uffdd\001\002\000\006\027\uffee\054\uffee" +
    "\001\002\000\006\027\075\054\013\001\002\000\026\005" +
    "\uffdc\007\uffdc\012\uffdc\013\uffdc\014\uffdc\016\uffdc\021\uffdc" +
    "\027\uffdc\030\uffdc\054\uffdc\001\002\000\026\005\uffd2\007" +
    "\uffd2\012\uffd2\013\uffd2\014\uffd2\016\uffd2\021\uffd2\027\uffd2" +
    "\030\uffd2\054\uffd2\001\002\000\026\005\116\007\105\012" +
    "\110\013\100\014\113\016\114\021\112\027\101\030\115" +
    "\054\102\001\002\000\004\023\242\001\002\000\026\005" +
    "\uffd2\007\uffd2\012\uffd2\013\uffd2\014\uffd2\016\uffd2\021\uffd2" +
    "\027\uffd2\030\uffd2\054\uffd2\001\002\000\060\023\uffa9\024" +
    "\uffa9\025\uffa9\026\uffa9\031\uffa9\032\uffa9\033\uffa9\034\uffa9" +
    "\035\uffa9\036\uffa9\037\uffa9\040\uffa9\041\uffa9\042\uffa9\043" +
    "\uffa9\044\uffa9\045\uffa9\046\uffa9\047\uffa9\050\uffa9\051\uffa9" +
    "\052\uffa9\053\uffa9\001\002\000\030\005\uffd0\007\uffd0\012" +
    "\uffd0\013\uffd0\014\uffd0\016\uffd0\017\uffd0\021\uffd0\027\uffd0" +
    "\030\uffd0\054\uffd0\001\002\000\016\023\234\025\171\033" +
    "\172\034\232\044\231\045\233\001\002\000\004\023\221" +
    "\001\002\000\026\005\uffd3\007\uffd3\012\uffd3\013\uffd3\014" +
    "\uffd3\016\uffd3\021\uffd3\027\uffd3\030\uffd3\054\uffd3\001\002" +
    "\000\004\031\220\001\002\000\004\023\214\001\002\000" +
    "\030\005\uffd1\007\uffd1\012\uffd1\013\uffd1\014\uffd1\016\uffd1" +
    "\017\uffd1\021\uffd1\027\uffd1\030\uffd1\054\uffd1\001\002\000" +
    "\004\031\213\001\002\000\020\011\124\023\136\031\211" +
    "\054\102\055\126\056\134\057\130\001\002\000\024\005" +
    "\116\007\105\012\110\013\100\014\113\016\114\021\112" +
    "\027\101\054\102\001\002\000\010\015\uffdb\030\uffdb\054" +
    "\uffdb\001\002\000\004\031\117\001\002\000\032\005\uffca" +
    "\007\uffca\010\uffca\012\uffca\013\uffca\014\uffca\016\uffca\017" +
    "\uffca\021\uffca\027\uffca\030\uffca\054\uffca\001\002\000\004" +
    "\017\121\001\002\000\004\023\122\001\002\000\016\011" +
    "\124\023\136\054\102\055\126\056\134\057\130\001\002" +
    "\000\030\024\uffaa\035\141\036\142\042\uffaa\043\uffaa\046" +
    "\uffaa\047\uffaa\050\uffaa\051\uffaa\052\uffaa\053\uffaa\001\002" +
    "\000\004\054\013\001\002\000\052\023\170\024\uffbb\025" +
    "\171\026\uffbb\031\uffbb\032\uffbb\033\172\035\uffbb\036\uffbb" +
    "\037\uffbb\040\uffbb\041\uffbb\042\uffbb\043\uffbb\046\uffbb\047" +
    "\uffbb\050\uffbb\051\uffbb\052\uffbb\053\uffbb\001\002\000\044" +
    "\024\uffb9\026\uffb9\031\uffb9\032\uffb9\035\uffb9\036\uffb9\037" +
    "\uffb9\040\uffb9\041\uffb9\042\uffb9\043\uffb9\046\uffb9\047\uffb9" +
    "\050\uffb9\051\uffb9\052\uffb9\053\uffb9\001\002\000\006\024" +
    "\165\043\164\001\002\000\044\024\uffb7\026\uffb7\031\uffb7" +
    "\032\uffb7\035\uffb7\036\uffb7\037\uffb7\040\uffb7\041\uffb7\042" +
    "\uffb7\043\uffb7\046\uffb7\047\uffb7\050\uffb7\051\uffb7\052\uffb7" +
    "\053\uffb7\001\002\000\024\024\uffac\042\uffac\043\uffac\046" +
    "\157\047\156\050\160\051\155\052\161\053\154\001\002" +
    "\000\044\024\uffbe\026\uffbe\031\uffbe\032\uffbe\035\uffbe\036" +
    "\uffbe\037\146\040\147\041\145\042\uffbe\043\uffbe\046\uffbe" +
    "\047\uffbe\050\uffbe\051\uffbe\052\uffbe\053\uffbe\001\002\000" +
    "\044\024\uffbc\026\uffbc\031\uffbc\032\uffbc\035\uffbc\036\uffbc" +
    "\037\uffbc\040\uffbc\041\uffbc\042\uffbc\043\uffbc\046\uffbc\047" +
    "\uffbc\050\uffbc\051\uffbc\052\uffbc\053\uffbc\001\002\000\044" +
    "\024\uffb8\026\uffb8\031\uffb8\032\uffb8\035\uffb8\036\uffb8\037" +
    "\uffb8\040\uffb8\041\uffb8\042\uffb8\043\uffb8\046\uffb8\047\uffb8" +
    "\050\uffb8\051\uffb8\052\uffb8\053\uffb8\001\002\000\010\024" +
    "\uffae\042\152\043\uffae\001\002\000\016\011\124\023\136" +
    "\054\102\055\126\056\134\057\130\001\002\000\010\024" +
    "\140\035\141\036\142\001\002\000\044\024\uffb4\026\uffb4" +
    "\031\uffb4\032\uffb4\035\uffb4\036\uffb4\037\uffb4\040\uffb4\041" +
    "\uffb4\042\uffb4\043\uffb4\046\uffb4\047\uffb4\050\uffb4\051\uffb4" +
    "\052\uffb4\053\uffb4\001\002\000\016\011\uffa0\023\uffa0\054" +
    "\uffa0\055\uffa0\056\uffa0\057\uffa0\001\002\000\016\011\uff9f" +
    "\023\uff9f\054\uff9f\055\uff9f\056\uff9f\057\uff9f\001\002\000" +
    "\016\011\124\023\136\054\102\055\126\056\134\057\130" +
    "\001\002\000\044\024\uffbf\026\uffbf\031\uffbf\032\uffbf\035" +
    "\uffbf\036\uffbf\037\146\040\147\041\145\042\uffbf\043\uffbf" +
    "\046\uffbf\047\uffbf\050\uffbf\051\uffbf\052\uffbf\053\uffbf\001" +
    "\002\000\016\011\uff9c\023\uff9c\054\uff9c\055\uff9c\056\uff9c" +
    "\057\uff9c\001\002\000\016\011\uff9e\023\uff9e\054\uff9e\055" +
    "\uff9e\056\uff9e\057\uff9e\001\002\000\016\011\uff9d\023\uff9d" +
    "\054\uff9d\055\uff9d\056\uff9d\057\uff9d\001\002\000\016\011" +
    "\124\023\136\054\102\055\126\056\134\057\130\001\002" +
    "\000\044\024\uffbd\026\uffbd\031\uffbd\032\uffbd\035\uffbd\036" +
    "\uffbd\037\uffbd\040\uffbd\041\uffbd\042\uffbd\043\uffbd\046\uffbd" +
    "\047\uffbd\050\uffbd\051\uffbd\052\uffbd\053\uffbd\001\002\000" +
    "\016\011\124\023\136\054\102\055\126\056\134\057\130" +
    "\001\002\000\024\024\uffad\042\uffad\043\uffad\046\157\047" +
    "\156\050\160\051\155\052\161\053\154\001\002\000\016" +
    "\011\uffa5\023\uffa5\054\uffa5\055\uffa5\056\uffa5\057\uffa5\001" +
    "\002\000\016\011\uffa1\023\uffa1\054\uffa1\055\uffa1\056\uffa1" +
    "\057\uffa1\001\002\000\016\011\uffa3\023\uffa3\054\uffa3\055" +
    "\uffa3\056\uffa3\057\uffa3\001\002\000\016\011\uffa4\023\uffa4" +
    "\054\uffa4\055\uffa4\056\uffa4\057\uffa4\001\002\000\016\011" +
    "\uffa2\023\uffa2\054\uffa2\055\uffa2\056\uffa2\057\uffa2\001\002" +
    "\000\016\011\uffa6\023\uffa6\054\uffa6\055\uffa6\056\uffa6\057" +
    "\uffa6\001\002\000\016\011\124\023\136\054\102\055\126" +
    "\056\134\057\130\001\002\000\030\024\uffab\035\141\036" +
    "\142\042\uffab\043\uffab\046\uffab\047\uffab\050\uffab\051\uffab" +
    "\052\uffab\053\uffab\001\002\000\016\011\124\023\136\054" +
    "\102\055\126\056\134\057\130\001\002\000\004\031\166" +
    "\001\002\000\032\005\uffcb\007\uffcb\010\uffcb\012\uffcb\013" +
    "\uffcb\014\uffcb\016\uffcb\017\uffcb\021\uffcb\027\uffcb\030\uffcb" +
    "\054\uffcb\001\002\000\010\024\uffaf\042\152\043\uffaf\001" +
    "\002\000\020\011\124\023\136\024\uffb2\054\102\055\126" +
    "\056\134\057\130\001\002\000\016\011\124\023\136\054" +
    "\102\055\126\056\134\057\130\001\002\000\004\054\173" +
    "\001\002\000\060\023\uffa8\024\uffa8\025\uffa8\026\uffa8\031" +
    "\uffa8\032\uffa8\033\uffa8\034\uffa8\035\uffa8\036\uffa8\037\uffa8" +
    "\040\uffa8\041\uffa8\042\uffa8\043\uffa8\044\uffa8\045\uffa8\046" +
    "\uffa8\047\uffa8\050\uffa8\051\uffa8\052\uffa8\053\uffa8\001\002" +
    "\000\010\026\175\035\141\036\142\001\002\000\060\023" +
    "\uffa7\024\uffa7\025\uffa7\026\uffa7\031\uffa7\032\uffa7\033\uffa7" +
    "\034\uffa7\035\uffa7\036\uffa7\037\uffa7\040\uffa7\041\uffa7\042" +
    "\uffa7\043\uffa7\044\uffa7\045\uffa7\046\uffa7\047\uffa7\050\uffa7" +
    "\051\uffa7\052\uffa7\053\uffa7\001\002\000\004\024\203\001" +
    "\002\000\012\024\uffb0\032\uffb0\035\141\036\142\001\002" +
    "\000\006\024\uffb3\032\201\001\002\000\016\011\124\023" +
    "\136\054\102\055\126\056\134\057\130\001\002\000\012" +
    "\024\uffb1\032\uffb1\035\141\036\142\001\002\000\044\024" +
    "\uffba\026\uffba\031\uffba\032\uffba\035\uffba\036\uffba\037\uffba" +
    "\040\uffba\041\uffba\042\uffba\043\uffba\046\uffba\047\uffba\050" +
    "\uffba\051\uffba\052\uffba\053\uffba\001\002\000\046\024\uffb5" +
    "\025\205\026\uffb5\031\uffb5\032\uffb5\035\uffb5\036\uffb5\037" +
    "\uffb5\040\uffb5\041\uffb5\042\uffb5\043\uffb5\046\uffb5\047\uffb5" +
    "\050\uffb5\051\uffb5\052\uffb5\053\uffb5\001\002\000\016\011" +
    "\124\023\136\054\102\055\126\056\134\057\130\001\002" +
    "\000\010\026\207\035\141\036\142\001\002\000\044\024" +
    "\uffb6\026\uffb6\031\uffb6\032\uffb6\035\uffb6\036\uffb6\037\uffb6" +
    "\040\uffb6\041\uffb6\042\uffb6\043\uffb6\046\uffb6\047\uffb6\050" +
    "\uffb6\051\uffb6\052\uffb6\053\uffb6\001\002\000\010\031\212" +
    "\035\141\036\142\001\002\000\032\005\uffc8\007\uffc8\010" +
    "\uffc8\012\uffc8\013\uffc8\014\uffc8\016\uffc8\017\uffc8\021\uffc8" +
    "\027\uffc8\030\uffc8\054\uffc8\001\002\000\032\005\uffc7\007" +
    "\uffc7\010\uffc7\012\uffc7\013\uffc7\014\uffc7\016\uffc7\017\uffc7" +
    "\021\uffc7\027\uffc7\030\uffc7\054\uffc7\001\002\000\032\005" +
    "\uffc9\007\uffc9\010\uffc9\012\uffc9\013\uffc9\014\uffc9\016\uffc9" +
    "\017\uffc9\021\uffc9\027\uffc9\030\uffc9\054\uffc9\001\002\000" +
    "\016\011\124\023\136\054\102\055\126\056\134\057\130" +
    "\001\002\000\010\024\216\035\141\036\142\001\002\000" +
    "\004\031\217\001\002\000\032\005\uffc5\007\uffc5\010\uffc5" +
    "\012\uffc5\013\uffc5\014\uffc5\016\uffc5\017\uffc5\021\uffc5\027" +
    "\uffc5\030\uffc5\054\uffc5\001\002\000\032\005\uffcd\007\uffcd" +
    "\010\uffcd\012\uffcd\013\uffcd\014\uffcd\016\uffcd\017\uffcd\021" +
    "\uffcd\027\uffcd\030\uffcd\054\uffcd\001\002\000\016\011\124" +
    "\023\136\054\102\055\126\056\134\057\130\001\002\000" +
    "\006\024\223\043\164\001\002\000\024\005\116\007\105" +
    "\012\110\013\100\014\113\016\114\021\112\027\101\054" +
    "\102\001\002\000\030\005\uffcf\007\uffcf\012\uffcf\013\uffcf" +
    "\014\uffcf\016\uffcf\017\uffcf\021\uffcf\027\uffcf\030\uffcf\054" +
    "\uffcf\001\002\000\032\005\uffd1\007\uffd1\010\226\012\uffd1" +
    "\013\uffd1\014\uffd1\016\uffd1\017\uffd1\021\uffd1\027\uffd1\030" +
    "\uffd1\054\uffd1\001\002\000\024\005\116\007\105\012\110" +
    "\013\100\014\113\016\114\021\112\027\101\054\102\001" +
    "\002\000\030\005\uffce\007\uffce\012\uffce\013\uffce\014\uffce" +
    "\016\uffce\017\uffce\021\uffce\027\uffce\030\uffce\054\uffce\001" +
    "\002\000\032\005\uffcc\007\uffcc\010\uffcc\012\uffcc\013\uffcc" +
    "\014\uffcc\016\uffcc\017\uffcc\021\uffcc\027\uffcc\030\uffcc\054" +
    "\uffcc\001\002\000\004\031\uffc1\001\002\000\016\011\124" +
    "\023\136\054\102\055\126\056\134\057\130\001\002\000" +
    "\004\031\uffc0\001\002\000\020\011\124\023\136\024\uffb2" +
    "\054\102\055\126\056\134\057\130\001\002\000\004\024" +
    "\236\001\002\000\004\031\uffc2\001\002\000\010\031\uffc3" +
    "\035\141\036\142\001\002\000\026\005\116\007\105\012" +
    "\110\013\100\014\113\016\114\021\112\027\101\030\241" +
    "\054\102\001\002\000\032\005\uffc4\007\uffc4\010\uffc4\012" +
    "\uffc4\013\uffc4\014\uffc4\016\uffc4\017\uffc4\021\uffc4\027\uffc4" +
    "\030\uffc4\054\uffc4\001\002\000\004\054\102\001\002\000" +
    "\010\024\244\025\171\033\172\001\002\000\004\031\245" +
    "\001\002\000\032\005\uffc6\007\uffc6\010\uffc6\012\uffc6\013" +
    "\uffc6\014\uffc6\016\uffc6\017\uffc6\021\uffc6\027\uffc6\030\uffc6" +
    "\054\uffc6\001\002\000\004\054\013\001\002\000\006\024" +
    "\uffd6\032\uffd6\001\002\000\010\024\uffe8\025\252\032\uffe8" +
    "\001\002\000\006\024\uffd4\032\uffd4\001\002\000\004\026" +
    "\253\001\002\000\010\024\uffe9\031\uffe9\032\uffe9\001\002" +
    "\000\012\006\uffe6\022\uffe6\027\uffe6\054\uffe6\001\002\000" +
    "\010\015\061\030\256\054\013\001\002\000\004\002\001" +
    "\001\002\000\010\025\252\031\uffe8\032\uffe8\001\002\000" +
    "\006\031\uffed\032\uffed\001\002\000\006\031\uffea\032\uffea" +
    "\001\002\000\006\031\264\032\263\001\002\000\004\054" +
    "\265\001\002\000\014\006\uffec\022\uffec\027\uffec\030\uffec" +
    "\054\uffec\001\002\000\010\025\252\031\uffe8\032\uffe8\001" +
    "\002\000\006\031\uffeb\032\uffeb\001\002\000\004\002\000" +
    "\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\265\000\004\002\003\001\001\000\002\001\001\000" +
    "\004\040\006\001\001\000\002\001\001\000\004\003\007" +
    "\001\001\000\014\004\015\006\013\010\014\016\016\043" +
    "\010\001\001\000\002\001\001\000\004\014\254\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\043\021\001\001\000\002\001\001\000\004\050\023\001" +
    "\001\000\002\001\001\000\004\042\027\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\051\031\001\001\000" +
    "\002\001\001\000\004\017\032\001\001\000\004\052\034" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\053\037\001\001\000\002\001\001\000\004" +
    "\042\041\001\001\000\002\001\001\000\004\011\043\001" +
    "\001\000\002\001\001\000\004\043\045\001\001\000\002" +
    "\001\001\000\004\055\047\001\001\000\004\005\050\001" +
    "\001\000\010\006\053\012\051\043\010\001\001\000\002" +
    "\001\001\000\004\014\054\001\001\000\002\001\001\000" +
    "\010\015\057\043\055\044\061\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\056\063\001\001\000\002\001\001" +
    "\000\012\020\066\021\070\022\067\043\065\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\057\072\001\001\000\004\005\073\001" +
    "\001\000\006\006\053\043\010\001\001\000\004\060\075" +
    "\001\001\000\004\025\076\001\001\000\014\026\105\032" +
    "\102\033\110\034\106\041\103\001\001\000\002\001\001" +
    "\000\004\025\237\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\012\041\124\045\131\046\207\047\132" +
    "\001\001\000\014\026\117\032\102\033\110\034\106\041" +
    "\103\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\020\035" +
    "\126\036\134\037\130\041\124\045\131\046\122\047\132" +
    "\001\001\000\004\027\142\001\001\000\004\043\203\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\031\161\001\001\000\004\030" +
    "\147\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\012\041\124\045\131\046\136\047\132\001" +
    "\001\000\004\027\142\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\010\041\124\045\143\047" +
    "\132\001\001\000\004\030\147\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\041\124\047" +
    "\150\001\001\000\002\001\001\000\014\037\152\041\124" +
    "\045\131\046\122\047\132\001\001\000\004\031\161\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\012\041\124\045\131\046\162\047\132\001\001\000\004" +
    "\027\142\001\001\000\016\036\166\037\130\041\124\045" +
    "\131\046\122\047\132\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\016\023\175\024\177\041" +
    "\124\045\131\046\176\047\132\001\001\000\012\041\124" +
    "\045\131\046\173\047\132\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\027\142\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\027\142\001\001\000\002\001" +
    "\001\000\012\041\124\045\131\046\201\047\132\001\001" +
    "\000\004\027\142\001\001\000\002\001\001\000\002\001" +
    "\001\000\012\041\124\045\131\046\205\047\132\001\001" +
    "\000\004\027\142\001\001\000\002\001\001\000\004\027" +
    "\142\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\012\041\124\045\131\046\214\047\132\001" +
    "\001\000\004\027\142\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\020\035\221\036\134\037" +
    "\130\041\124\045\131\046\122\047\132\001\001\000\002" +
    "\001\001\000\014\026\223\032\102\033\224\034\106\041" +
    "\103\001\001\000\002\001\001\000\002\001\001\000\012" +
    "\032\226\033\227\034\106\041\103\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\012\041\124" +
    "\045\131\046\236\047\132\001\001\000\002\001\001\000" +
    "\016\023\234\024\177\041\124\045\131\046\176\047\132" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\027" +
    "\142\001\001\000\014\026\105\032\102\033\110\034\106" +
    "\041\103\001\001\000\002\001\001\000\004\041\242\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\006\021\246\043\065\001\001\000\002\001\001\000" +
    "\004\013\250\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\010\015\057\043" +
    "\055\044\061\001\001\000\002\001\001\000\004\013\257" +
    "\001\001\000\004\054\260\001\001\000\004\007\261\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\013\265\001\001\000\002\001\001\000\002\001" +
    "\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$MJParser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$MJParser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$MJParser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {

	Tab.init(); // Universe scope
	boolType = new Struct(Struct.Bool);
	Obj boolObj = new Obj(Obj.Type, "bool", boolType);
	Tab.currentScope().addToLocals(boolObj);
	scopeStack = new Stack<ScopeEnum>();
	scopeStack.push(ScopeEnum.GLOBAL);

    }

  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {

	Symbol s = this.getScanner().next_token();	
	//if (s != null && s.value != null) 
	//	log.info(s.toString() + " " + s.value.toString() + " \t\tline: " + s.left);
	return s;

    }


	
	int printCallCount = 0;
	boolean errorDetected = false;

	Struct boolType;

	int globalConstCount = 0;
	int globalVarCount = 0;

	public enum ScopeEnum {
		GLOBAL,
		LOCAL,
		CLASS
	}

	Stack<ScopeEnum> scopeStack;

	Logger log = Logger.getLogger(getClass());
   

   	public boolean isCurrentScope(ScopeEnum type){
		   return type == scopeStack.peek();
	}

	public void push(ScopeEnum type){
		scopeStack.push(type);
	}

	public boolean popCheck(ScopeEnum type){
		if(scopeStack.isEmpty()) { report_error("Stack je prazan ", null);  return false;}
		ScopeEnum e = scopeStack.pop();
		if(e!=type){
			report_error("Ocekivan je " + type + " a nadjen " + e ,null);
			return false;
		}
		return true;
	}
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$MJParser$actions {


	boolean constDecl = false;
	boolean returnFound = false;
	Obj currentMethod = null;
	Obj currentClass = null;
	Struct currentType = null;
	Struct listDeclType = Tab.nullType;
	boolean isArrayType = false;

	


	boolean isFirstDeclaration(String name, int line)
	{
		if(Tab.currentScope.findSymbol(name)==null)
			return true;
		else {
			parser.report_error("Greska na liniji " + line + " - promenljiva " + name + " je vec deklarisana", null);
			return false;
		}
	}

  private final MJParser parser;

  /** Constructor */
  CUP$MJParser$actions(MJParser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$MJParser$do_action(
    int                        CUP$MJParser$act_num,
    java_cup.runtime.lr_parser CUP$MJParser$parser,
    java.util.Stack            CUP$MJParser$stack,
    int                        CUP$MJParser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$MJParser$result;

      /* select the action based on the action number */
      switch (CUP$MJParser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // Mulop ::= MOD 
            {
              Object RESULT =null;
		 RESULT = Code.mul; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // Mulop ::= DIV 
            {
              Object RESULT =null;
		 RESULT = Code.div; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // Mulop ::= MUL 
            {
              Object RESULT =null;
		 RESULT = Code.mul; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // Addop ::= MINUS 
            {
              Object RESULT =null;
		 RESULT = Code.sub; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Addop",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // Addop ::= PLUS 
            {
              Object RESULT =null;
		 RESULT = Code.add; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Addop",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // Relop ::= LESS_OR_EQUAL 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // Relop ::= LESS 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // Relop ::= GREATER_OR_EQUAL 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // Relop ::= GREATER 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // Relop ::= NOT_EQUAL 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // Relop ::= IS_EQUAL 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // Designator ::= Designator LBRACKET Expr RBRACKET 
            {
              Obj RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct exp = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
					if (exp != Tab.intType) {
						parser.report_error("Greska na liniji " + expleft + ": izraz unutar zagrada [] mora biti tipa int", null);
						RESULT = Tab.noObj;
					} else {
						if (d.getType().getKind() == Struct.Array) {
							RESULT = new Obj(Obj.Elem, "DesignatorArray", d.getType().getElemType());
						} else {
							parser.report_error("Greskaa na liniji " + dleft + ": " + d.getName() + " mora biti niz", null);
							RESULT = Tab.noObj;
						}
					}

			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Designator",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // Designator ::= Designator DOT IDENT 
            {
              Obj RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Designator",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // Designator ::= IDENT 
            {
              Obj RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					Obj obj = Tab.find(name);
					if (obj == Tab.noObj) { 
						parser.report_error("Greska na liniji " + nameleft + " : ime " + name + " nije deklarisano! ", null);
					}
					RESULT = obj;
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Designator",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // CondFact ::= Expr 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFact",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // CondFact ::= CondFact Relop Expr 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFact",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // CondTerm ::= CondFact 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTerm",28, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // CondTerm ::= CondTerm LOGICAL_AND CondFact 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTerm",28, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // Condition ::= CondTerm 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Condition",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // Condition ::= Condition LOGICAL_OR CondTerm 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Condition",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // ActualParamList ::= Expr 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActualParamList",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // ActualParamList ::= ActualParamList COMMA Expr 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActualParamList",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // ActualPars ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActualPars",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // ActualPars ::= ActualParamList 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActualPars",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // Factor ::= LPAREN Expr RPAREN 
            {
              Struct RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct exp = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 RESULT = exp; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // Factor ::= NEW Type 
            {
              Struct RESULT =null;
		 parser.report_info("new1 ", null); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // Factor ::= NEW Type LBRACKET Expr RBRACKET 
            {
              Struct RESULT =null;
		 parser.report_info("new2 ", null); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // Factor ::= BOOL_CONST 
            {
              Struct RESULT =null;
		 RESULT = parser.boolType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // Factor ::= CHAR_CONST 
            {
              Struct RESULT =null;
		 RESULT = Tab.charType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // Factor ::= NUM_CONST 
            {
              Struct RESULT =null;
		 RESULT = Tab.intType; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // Factor ::= Designator LPAREN ActualPars RPAREN 
            {
              Struct RESULT =null;
		int funcleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int funcright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj func = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		
		       if (Obj.Meth == func.getKind()) { 
		   	   	   parser.report_info("Pronadjen poziv funkcije " + func.getName() + " na liniji " + funcleft, null);
		   	   	   if (func.getType() == Tab.noType) { 
		   	   	   		parser.report_error("Semanticka greska " + func.getName() + " ne moze se koristiti u izrazima jer nema povratnu vrednost, linija " + funcleft, null);
		   	   	   	}
		   	   	   	else {
		   	   	   		int destAdr = func.getAdr() - Code.pc;
		   	   	   		Code.put(Code.call);
		   	   	   		Code.put2(destAdr);
		   	   	   }
		   	   	   RESULT = func.getType();
		   	   } else {
		   	   	   parser.report_error("Greska na liniji " + funcleft+" : ime " + func.getName() + " nije funkcija!", null);
		   	   	   RESULT = Tab.noType;
		   	   }
		    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // Factor ::= Designator 
            {
              Struct RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
		   		RESULT = d.getType();
		   		Code.load(d); 
		    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // Term ::= Factor 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = t; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Term",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // Term ::= Term Mulop Factor 
            {
              Struct RESULT =null;
		int teleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int teright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct te = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			if (te.equals(t) && te == Tab.intType)
					RESULT = te;
				else {
					parser.report_error("Greska na liniji "+ teleft+" : nekompatibilni tipovi u izrazu za mnozenje.", null);
					RESULT = Tab.noType;
				} 
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Term",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // Expr ::= Term 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = t; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expr",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // Expr ::= Expr Addop Term 
            {
              Struct RESULT =null;
		int teleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int teright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct te = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			if (te.equals(t) && te == Tab.intType)
				RESULT = te;
			else {
				parser.report_error("Greska na liniji "+ teleft+" : nekompatibilni tipovi u izrazu za sabiranje.", null);
				RESULT = Tab.noType;
			} 
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expr",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // DesignatorStatement ::= Designator DEC 
            {
              Object RESULT =null;
		 parser.report_info("--", null); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // DesignatorStatement ::= Designator INC 
            {
              Object RESULT =null;
		 parser.report_info("++", null); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // DesignatorStatement ::= Designator LPAREN ActualPars RPAREN 
            {
              Object RESULT =null;
		 parser.report_info("()", null); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // DesignatorStatement ::= Designator EQUAL Expr 
            {
              Object RESULT =null;
		 parser.report_info("=", null); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // Matched ::= LBRACE StatementList RBRACE 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // Matched ::= PRINT LPAREN Expr RPAREN SEMI 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
			  	parser.printCallCount++;
			  	 if (t != Tab.intType && t != Tab.charType)
			  	 	parser.report_error("Semanticka greska na liniji " + tleft + ": Operand instrukcije PRINT mora biti char ili int tipa ", null);
			  	 if (t == Tab.intType) {
			  	 	Code.loadConst(5);
			  	 	Code.put(Code.print);
			  	 }
			  	 
			  	 if (t == Tab.charType) {
			  	 	Code.loadConst(1);
			  	 	Code.put(Code.bprint);
			  	 }
				 //System.out.println("Print gotov");
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // Matched ::= READ LPAREN Designator RPAREN SEMI 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // Matched ::= RETURN Expr SEMI 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
			  	 returnFound = true;
				 Struct currMethType = currentMethod.getType();
				 if (!currMethType.compatibleWith(t)) {
				 	parser.report_error("Greska na liniji " + tleft + " : " + "tip izraza u return naredbi ne slaze se sa tipom povratne vrednosti funkcije " + currentMethod.getName(), null);
				 }			  	 
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // Matched ::= RETURN SEMI 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // Matched ::= CONTINUE SEMI 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // Matched ::= BREAK SEMI 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // Matched ::= DO Statement WHILE LPAREN Condition RPAREN SEMI 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // Matched ::= IF LPAREN Condition RPAREN Matched ELSE Matched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // Matched ::= DesignatorStatement SEMI 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // Unmatched ::= IF LPAREN Condition RPAREN Matched ELSE Unmatched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // Unmatched ::= IF LPAREN Condition RPAREN Statement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // Statement ::= Unmatched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // Statement ::= Matched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // StatementList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementList",19, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // StatementList ::= StatementList Statement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementList",19, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // FormalParamDecl ::= Type IDENT ArrayBrackets 
            {
              Object RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
						if(isFirstDeclaration(name, nameleft) && type != Tab.nullType){
							Struct methType = type;
							if(isArrayType){
								methType = new Struct(Struct.Array, type);
							}
							Tab.insert(Obj.Var, name, methType);
							parser.report_info("Formalni parametar " + name ,null);
						}
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamDecl",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // FormalParamList ::= FormalParamDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamList",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // FormalParamList ::= FormalParamList COMMA FormalParamDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamList",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // FormPars ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPars",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // FormPars ::= FormalParamList 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPars",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // MethType ::= VOID 
            {
              Struct RESULT =null;
		
			 	RESULT = Tab.noType;
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethType",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // MethType ::= Type 
            {
              Struct RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			 	RESULT = type;
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethType",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // MethodDecl ::= MethType IDENT NT$6 LPAREN FormPars RPAREN NT$7 VarDeclList LBRACE NT$8 StatementList RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$8
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int retTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)).left;
		int retTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)).right;
		Struct retType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)).value;
		
			   	 if (!returnFound && retType != Tab.noType)
			   	 	parser.report_error("Semanticka greska na liniji " + methNameleft + ": funcija " + methName + " nema return iskaz!", null);
				
				 Code.put(Code.exit);
				 Code.put(Code.return_);
				  
				 Tab.chainLocalSymbols(currentMethod);
			   	 Tab.closeScope();
			   	 
				 returnFound = false;
				 currentMethod = null;
				 
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDecl",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // NT$8 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int retTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).left;
		int retTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).right;
		Struct retType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).value;
 
			   		parser.popCheck(ScopeEnum.LOCAL);
			   		currentMethod.setAdr(Code.pc);
			   		if ("main".equals(methName)) {
			   			Code.mainPc = currentMethod.getAdr();
			   		}
			   		Code.put(Code.enter);
			   		Code.put(currentMethod.getLevel());
			   		Code.put(Tab.currentScope().getnVars());
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$8",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // NT$7 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int retTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int retTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		Struct retType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;

					parser.push(ScopeEnum.LOCAL);
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$7",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // NT$6 ::= 
            {
              Object RESULT =null;
		int retTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int retTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct retType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

					if(isFirstDeclaration(methName, methNameleft) && retType!=Tab.nullType){
						currentMethod = Tab.insert(Obj.Meth, methName, (Struct) retType);
						parser.report_info("Obradjuje se funkcija " + methName + " na liniji " + methNameleft, null);
						Tab.openScope();
					}
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$6",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // MethodDeclList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclList",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // MethodDeclList ::= MethodDeclList MethodDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclList",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // Type ::= IDENT 
            {
              Struct RESULT =null;
		int typeNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String typeName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
	Obj typeNode = Tab.find(typeName);
	if (typeNode == Tab.noObj) {
		parser.report_error("Nije pronadjen tip " + typeName + " u tabeli simbola", null);
		RESULT = Tab.noType;
	}
	else {
		if (Obj.Type == typeNode.getKind()) {
			RESULT = typeNode.getType();
		}
		else {
			parser.report_error("Greska na liniji" + typeNameleft+ ": Ime " + typeName + " ne predstavlja tip ", null);
			RESULT = Tab.noType;
		}
	}

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Type",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // ExtendsDecl ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExtendsDecl",7, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // ExtendsDecl ::= EXTENDS Type 
            {
              Object RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
						if(type.getKind()==Struct.Class)
							RESULT = type;
						else {
							parser.report_info("Greska na liniji " + typeleft + " extends tip nije klasa", null);
							RESULT = Tab.nullType;
						} 
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExtendsDecl",7, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // ClassMethodDeclList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassMethodDeclList",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // ClassMethodDeclList ::= LBRACE MethodDeclList RBRACE 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassMethodDeclList",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // ClassDecl ::= CLASS IDENT ExtendsDecl LBRACE NT$5 VarDeclList ClassMethodDeclList RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		Object type = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		
					parser.popCheck(ScopeEnum.CLASS);
					Tab.chainLocalSymbols(currentClass);
					Tab.closeScope();
					currentClass = null;
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassDecl",6, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // NT$5 ::= 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object type = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
 
			  		parser.push(ScopeEnum.CLASS);
					if(isFirstDeclaration(name, nameleft) && type != Tab.nullType){
						currentClass = Tab.insert(Obj.Type, name, new Struct(Struct.Class));
						parser.report_info("Deklarisana klasa " + name + " na liniji " + nameleft, null);
						Tab.openScope();
					}
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$5",43, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // ArrayBrackets ::= 
            {
              Object RESULT =null;
		 isArrayType = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ArrayBrackets",9, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // ArrayBrackets ::= LBRACKET RBRACKET 
            {
              Object RESULT =null;
		 isArrayType = true; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ArrayBrackets",9, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // VarAdditional ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarAdditional",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // VarAdditional ::= VarAdditional COMMA IDENT ArrayBrackets 
            {
              Object RESULT =null;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
				  		if(isFirstDeclaration(varName, varNameleft)){
							Obj temp = Tab.find(varName);
							if(temp == Tab.noObj)
								parser.report_error("Promenljiva " + varName + " je vec bila deklarisana. Linija: " + varNameleft, null);
							else
							{
								Struct type = currentType;
								
								if(isArrayType)
									type = new Struct(Struct.Array, currentType);

								if(currentClass!=null){
									Tab.insert(Obj.Fld, varName, currentType);
									parser.report_info("Deklarisano polje klase " + currentClass.getName() + ":"+ varName+ " na liniji "+ varNameleft, null);
								} else {
									Tab.insert(Obj.Var, varName, currentType);
									if(parser.scopeStack.peek()==ScopeEnum.LOCAL){
										parser.report_info("Deklarisana lokalna promenljiva "+ varName+ " na liniji "+ varNameleft, null);
									} else 
									parser.report_info("Deklarisana promenljiva "+ varName+ " na liniji "+ varNameleft, null);
								}
							}
						}
				
				  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarAdditional",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // VarDecl ::= Type IDENT ArrayBrackets NT$4 VarAdditional SEMI 
            {
              Object RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int varTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int varTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		Struct varType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		 currentType = null; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDecl",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // NT$4 ::= 
            {
              Object RESULT =null;
		int varTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int varTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct varType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String varName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;

				currentType = varType;
				if(isFirstDeclaration(varName, varNameleft)){
					Obj temp = Tab.find(varName);
					if(temp != Tab.noObj)
						parser.report_error("Promenljiva " + varName + " je vec bila deklarisana. Linija: " + varNameleft, null);
					else
					{
						Struct type = varType;
						
						if(isArrayType)
							type = new Struct(Struct.Array, varType);
						if(currentClass!=null){
							Tab.insert(Obj.Fld, varName, type);
							parser.report_info("Deklarisano polje klase " + currentClass.getName() + ":"+ varName+ " na liniji "+ varNameleft, null);
						} else {
							Tab.insert(Obj.Var, varName, type);
							if(parser.scopeStack.peek()==ScopeEnum.LOCAL){
								parser.report_info("Deklarisana lokalna promenljiva "+ varName+ " na liniji "+ varNameleft, null);
							} else 
							parser.report_info("Deklarisana globalna promenljiva "+ varName+ " na liniji "+ varNameleft, null);
						}
					}
				}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$4",42, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // VarDeclList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclList",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // VarDeclList ::= VarDeclList VarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclList",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // ConstAssigment ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstAssigment",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // ConstAssigment ::= ConstAssigment COMMA IDENT NT$3 EQUAL ConstValue 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int valueleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valueright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj value = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
						if(currentType!=value.getType())
						{
							parser.report_info("Greska tipovi se ne slazu, konstanta " + name + " : " + nameleft + " na liniji "+ nameleft, null);
						}
						else if (currentType.getKind() == Struct.Array){
							if(currentType.getElemType() != value.getType().getElemType()){
								parser.report_info("Greska tipovi se ne slazu niz, konstanta " + name + " : " + nameleft + " na liniji "+ nameleft, null);
							}
						}
			  	   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstAssigment",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // NT$3 ::= 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

				    	if(isFirstDeclaration(name, nameleft) && listDeclType != Tab.nullType)
						{	
							Obj temp = Tab.insert(Obj.Con, name, currentType);
							parser.report_info("Deklarisana konstanta "+ name+" na liniji "+ nameleft, null);
						}
				   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$3",41, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // ConstValue ::= BOOL_CONST 
            {
              Obj RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Boolean b = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			   		if(constDecl && parser.isCurrentScope(ScopeEnum.GLOBAL))
						parser.globalConstCount++;
					RESULT = new Obj(Obj.Con, "boolValue", Tab.find("bool").getType(), b?1:0, 0);
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstValue",32, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // ConstValue ::= CHAR_CONST 
            {
              Obj RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Character c = (Character)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			   		if(constDecl && parser.isCurrentScope(ScopeEnum.GLOBAL))
						parser.globalConstCount++;
					RESULT = new Obj(Obj.Con, "charValue", Tab.charType, c, 0);
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstValue",32, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // ConstValue ::= NUM_CONST 
            {
              Obj RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer i = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			   		if(constDecl && parser.isCurrentScope(ScopeEnum.GLOBAL))
						parser.globalConstCount++; 
					RESULT = new Obj(Obj.Con, "numValue", Tab.intType, i, 0);
					// provera tipa
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstValue",32, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // ConstDecl ::= CONST Type IDENT NT$0 EQUAL ConstValue NT$1 ConstAssigment NT$2 SEMI 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).value;
		int valueleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int valueright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Obj value = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDecl",12, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // NT$2 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		int valueleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int valueright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj value = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
 currentType = null; constDecl = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$2",40, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // NT$1 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int valueleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valueright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj value = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
 
					if(type!=value.getType())
					{
						parser.report_info("Greska tipovi se ne slazu, konstanta " + name + " : " + nameleft + " na liniji "+ nameleft, null);
					}
					else if (type.getKind() == Struct.Array){
						if(type.getElemType() != value.getType().getElemType()){
							parser.report_info("Greska tipovi se ne slazu niz, konstanta " + name + " : " + nameleft + " na liniji "+ nameleft, null);
						}
					}
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$1",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // NT$0 ::= 
            {
              Object RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

			  		constDecl = true;
					currentType = type;
					if(isFirstDeclaration(name, nameleft))
					{	
						Obj temp = Tab.insert(Obj.Con, name, type);
						parser.report_info("Deklarisana konstanta "+ name + " na liniji "+ nameleft, null);
					}
					listDeclType = type;
              
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$0",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // ProgDecl ::= ClassDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ProgDecl",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // ProgDecl ::= VarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ProgDecl",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // ProgDecl ::= ConstDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ProgDecl",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // ProgDeclList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ProgDeclList",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // ProgDeclList ::= ProgDeclList ProgDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ProgDeclList",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // ProgName ::= IDENT 
            {
              Obj RESULT =null;
		int pNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int pNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String pName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		  
	RESULT = Tab.insert(Obj.Prog, pName, Tab.noType);
	Tab.openScope(); 

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ProgName",30, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= Program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		RESULT = start_val;
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$MJParser$parser.done_parsing();
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // Program ::= PROG ProgName ProgDeclList LBRACE MethodDeclList RBRACE 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Obj p = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		
	Code.dataSize = Tab.currentScope().getnVars();
	Tab.chainLocalSymbols(p);
	Tab.closeScope(); 

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Program",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

