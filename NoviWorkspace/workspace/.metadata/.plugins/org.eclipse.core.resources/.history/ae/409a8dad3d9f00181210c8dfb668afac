package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import java.util.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.mj.runtime.Code;

parser code {:

	Logger log = Logger.getLogger(getClass());
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();	
	//if (s != null && s.value != null) 
	//	log.info(s.toString() + " " + s.value.toString() + " \t\tline: " + s.left);
	return s;
:}

init with {:
	Tab.init(); // Universe scope
	boolType = new Struct(Struct.Bool);
	Obj boolObj = new Obj(Obj.Type, "bool", boolType);
	Tab.currentScope().addToLocals(boolObj);
	scopeStack = new Stack<ScopeEnum>();
	scopeStack.push(ScopeEnum.GLOBAL);
:}

action code {:
	boolean constDecl = false;
	boolean returnFound = false;
	Obj currentMethod = null;
	Obj currentClass = null;
	Struct currentType = null;
	Struct listDeclType = Tab.nullType;
	boolean isArrayType = false;
	boolean noArgs = false;

	


	boolean isFirstDeclaration(String name, int line)
	{
		if(Tab.currentScope.findSymbol(name)==null)
			return true;
		else {
			parser.report_error("Greska na liniji " + line + " - promenljiva " + name + " je vec deklarisana", null);
			return false;
		}
	}
:}

terminal PROG;
terminal BREAK, CLASS, IF, ELSE, NEW, PRINT, READ, RETURN, VOID, DO, WHILE, EXTENDS, CONTINUE, CONST;

terminal LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE;
terminal SEMI, COMMA, DOT;
terminal EQUAL, PLUS, MINUS, MUL, DIV, MOD, LOGICAL_AND, LOGICAL_OR, INC, DEC;
terminal GREATER, GREATER_OR_EQUAL, LESS, LESS_OR_EQUAL, IS_EQUAL, NOT_EQUAL;

terminal String IDENT;
terminal Integer NUM_CONST;
terminal Character CHAR_CONST;
terminal java.lang.Boolean BOOL_CONST;

non terminal Program, ProgDeclList, ProgDecl;
non terminal VarDeclList, VarDecl, VarAdditional, VarAssigment;
non terminal ClassDecl, ExtendsDecl, ClassMethodDeclList;
non terminal ArrayBrackets;
non terminal MethodDeclList, MethodDecl;
non terminal ConstDecl, ConstAssigment, ConstAssigmentList, ConstValue;
non terminal FormalParamList, FormalParamDecl, FormPars, ActualPars, ActualParamList; 
non terminal StatementList, Statement, Addop, Mulop, Relop;
non terminal DesignatorStatement;
non terminal Condition, CondTerm, CondFact;
non terminal Obj ProgName, Designator;
non terminal Struct Type, MethType, Term, Expr, Factor;
precedence left ELSE;

Program ::= (Program) PROG ProgName:progName ProgDeclList LBRACE MethodDeclList RBRACE ;

ProgName ::= (ProgName) IDENT:progName;

ProgDeclList ::= (ProgDeclsList) ProgDeclList ProgDecl
				 |
				 (NoProgDeclsList)
				 /* epsilon */
				 ;

ProgDecl ::= (ProgConstDecl) ConstDecl
			 |
			 (ProgVarDecl) VarDecl
			 |
			 (ProgClassDecl) ClassDecl
			 ;


ConstDecl ::=  (ConstDecl) CONST Type ConstAssigment ConstAssigmentList SEMI;

ConstValue ::= (NumConst) NUM_CONST:numValue
			   |
			   (CharConst) CHAR_CONST:charValue
			   |
			   (BoolConst) BOOL_CONST:boolValue
			   ;

ConstAssigment ::= (ConstAssigment) IDENT EQUAL ConstValue; 

ConstAssigmentList ::= (ConstAssigmentsList) COMMA ConstAssigment
					   |
					   (NoConstAssigmentsList)
					   /* epsilon */
					   ;

VarDeclList ::= (VarDeclsList) VarDeclList VarDecl  
				|
				(NoVarDeclsList)
				/* epsilon */ 
				;

VarDecl ::= (VarDecl) Type:varType VarAssigment VarAdditional SEMI; 

VarAssigment ::= (VarAssigment) IDENT:varName ArrayBrackets;

VarAdditional ::= (VarsAdditional) VarAdditional COMMA VarAssigment
				  |
				  (NoVarsAdditional)
				  /* epsilon */
				  ;


ArrayBrackets ::= (ArrayBracket) LBRACKET RBRACKET
				  |
				  (NoArrayBracket)
				  /* epsilon */
				  ;

ClassDecl ::= (ClassDecl) CLASS IDENT:name ExtendsDecl:type LBRACE VarDeclList ClassMethodDeclList RBRACE;

ClassMethodDeclList ::= (ClassMethodDeclsList) LBRACE MethodDeclList RBRACE 
						|
						(NoClassMethodDeclsList)
						/* epsilon */
						;

ExtendsDecl ::= (ExtendsDecls) EXTENDS Type
				|
				(NoExtendsDecls)
				/* epsilon */
				;

Type ::= (Type) IDENT:typeName;

MethodDeclList ::=  (MethodDeclsList) MethodDeclList MethodDecl
					|
					(NoMethodDeclsList)
					/* epsilon */
					;

MethodDecl ::= (MethodDecl) MethType:retType IDENT:methName LPAREN FormPars RPAREN VarDeclList LBRACE StatementList RBRACE;

MethType ::= (MethTypeNotVoid) Type
			 |
			 (MethTypeVoid) VOID
			 ;
				

FormPars ::= (FormsPars) FormalParamList 
			 |
			 (NoFormPars)
			 /* epsilon */
			 ;

FormalParamList ::= (FormalParamsList) FormalParamList COMMA FormalParamDecl
					|
					(FormalParamSingleDecl) FormalParamDecl
					;

FormalParamDecl ::= (FormalParamDecl) Type:type IDENT:name ArrayBrackets;

StatementList ::= 	(StatementsList) StatementList Statement
					|
					(NoStatementsList)
				  	/* epsilon */
				  	;


Statement ::= (DesignatorSingleStatement) DesignatorStatement SEMI
			  |
			  (IfElse) IF LPAREN Condition RPAREN Statement ELSE Statement
			  |
			  (If) IF LPAREN Condition RPAREN Statement
			  |
			  (DoWhile) DO Statement WHILE LPAREN Condition RPAREN SEMI
			  |
			  (Break) BREAK SEMI
			  |
			  (Continue) CONTINUE SEMI
			  |
			  (ReturnVoid) RETURN SEMI
			  |
			  (Return) RETURN Expr:t SEMI
			  |
			  (Read) READ LPAREN Designator RPAREN SEMI
			  |
			  (Print) PRINT LPAREN Expr:t RPAREN SEMI 
			  |
			  (BraceStatementList) LBRACE StatementList RBRACE
			  ;

DesignatorStatement ::= (DesignatorAssigment) Designator:d EQUAL Expr:e
						|
						(DesignatorFuncCall) Designator:d LPAREN ActualPars:pars RPAREN
						|
						(DesignatorInc) Designator:d INC
						|
						(DesignatorDec) Designator:d DEC		
						;


				  
Expr ::= (ExprList) Expr:te Addop Term:t
		 |
		 (ExprTerm) Term:t
		 ;

					
Term ::= (TermList) Term:te Mulop Factor:t
     	 | 
     	 (TermFactor) Factor:t
     	 ; 



Factor ::=  (FactorDesignator) Designator:d
		    |
		    (FactorDesignatorFuncCall) Designator:func LPAREN ActualPars RPAREN
		    |
			(FactorConstValue) ConstValue
			|
			(FactorNewArray) NEW Type LBRACKET Expr RBRACKET
			|
			(FactorNew) NEW Type
			|
			(FactorExpr) LPAREN Expr:exp RPAREN
		    ;
  
ActualPars ::=  (ActualParsList) ActualParamList 
				| 
				(NoActualParsList)
			    /* epsilon */ 
			    ;
			   
ActualParamList ::= (ActualParamsList) ActualParamList COMMA Expr
					|
					(ActualParamsListExpr)
					Expr
					;

Condition ::= (ConditionOrList) Condition LOGICAL_OR CondTerm 
        	  | 
        	  (ConditionCondTerm) CondTerm 
        	  ; 

CondTerm ::=  (CondTermAndList) CondTerm LOGICAL_AND CondFact 
        	  | 
        	  (CondTermCondFact) CondFact 
        	  ; 

CondFact ::= (CondFactRelopList) CondFact Relop Expr 
       		 |
			 (CondFactExpr) Expr  
       		 ; 
	
Designator ::= (DesignatorIdent) IDENT:name
			   |
			   (DesignatorAccessMember) Designator DOT IDENT
			   |
			   (DesignatorArray) Designator:d LBRACKET Expr:exp RBRACKET
			   ;


Relop ::= (RelopIsEqual) IS_EQUAL 
		  | 
		  (RelopNotEqual) NOT_EQUAL 
		  |
		  (RelopGreater) GREATER 
		  | 
		  (RelopGreaterOrEqual) GREATER_OR_EQUAL 
		  | 
		  (RelopLess) LESS 
		  | 
		  (RelopLessOrEqual) LESS_OR_EQUAL;

Addop ::= (AddopPlus) PLUS
		  |
		  (AddopMinus) MINUS
		  ;

Mulop ::= (MulopMul) MUL
		  | 
		  (MulopDiv) DIV
		  | 
 		  (MulopMod) MOD
		  ;